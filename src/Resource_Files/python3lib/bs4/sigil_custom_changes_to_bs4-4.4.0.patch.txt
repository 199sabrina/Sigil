diff -ur bs4_4.4_official/__init__.py bs4_4.4_custom/__init__.py
--- bs4_4.4_official/__init__.py	2015-09-05 19:23:38.000000000 -0400
+++ bs4_4.4_custom/__init__.py	2015-09-05 19:46:59.000000000 -0400
@@ -420,7 +420,7 @@
 
     def decode(self, pretty_print=False,
                eventual_encoding=DEFAULT_OUTPUT_ENCODING,
-               formatter="minimal"):
+               formatter="minimal", indent_chars=" "):
         """Returns a string or Unicode representation of this document.
         To get Unicode, pass None for encoding."""
 
@@ -437,7 +437,28 @@
         else:
             indent_level = 0
         return prefix + super(BeautifulSoup, self).decode(
-            indent_level, eventual_encoding, formatter)
+            indent_level, eventual_encoding, formatter, indent_chars)
+
+    def decodexml(self, indent_level=0, eventual_encoding=DEFAULT_OUTPUT_ENCODING,
+               formatter="minimal", indent_chars=" "):
+        """Returns a string or Unicode representation of this document.
+        as pretty printed xml"""
+
+        # Print the XML declaration
+        encoding_part = ''
+        if eventual_encoding != None:
+            encoding_part = ' encoding="%s"' % eventual_encoding
+        prefix = '<?xml version="1.0"%s?>\n' % encoding_part
+        return prefix + super(BeautifulSoup, self).decodexml(
+            indent_level, eventual_encoding, formatter, indent_chars)
+
+    def serialize(self, eventual_encoding=DEFAULT_OUTPUT_ENCODING):
+        encoding_part = ''
+        if eventual_encoding != None:
+            encoding_part = ' encoding="%s"' % eventual_encoding
+        prefix = '<?xml version="1.0"%s?>\n' % encoding_part
+        return prefix + super(BeautifulSoup, self).serialize(eventual_encoding)
+
 
 # Alias to make it easier to type import: 'from bs4 import _soup'
 _s = BeautifulSoup
diff -ur bs4_4.4_official/builder/_lxml.py bs4_4.4_custom/builder/_lxml.py
--- bs4_4.4_official/builder/_lxml.py	2015-09-05 19:23:39.000000000 -0400
+++ bs4_4.4_custom/builder/_lxml.py	2015-09-05 20:33:40.000000000 -0400
@@ -137,24 +137,29 @@
         # Make sure attrs is a mutable dict--lxml may send an immutable dictproxy.
         attrs = dict(attrs)
         nsprefix = None
+
+        # Fix bug in bs4 _lxml.py that ignores attributes that specify namespaces on this tag
+
         # Invert each namespace map as it comes in.
-        if len(self.nsmaps) > 1:
-            # There are no new namespaces for this tag, but
-            # non-default namespaces are in play, so we need a
-            # separate tag stack to know when they end.
-            self.nsmaps.append(None)
-        elif len(nsmap) > 0:
+        if len(nsmap) > 0:
             # A new namespace mapping has come into play.
             inverted_nsmap = dict((value, key) for key, value in list(nsmap.items()))
             self.nsmaps.append(inverted_nsmap)
+        
             # Also treat the namespace mapping as a set of attributes on the
-            # tag, so we can recreate it later.
+            # tag, so we can properly recreate it later.
             attrs = attrs.copy()
             for prefix, namespace in list(nsmap.items()):
                 attribute = NamespacedAttribute(
                     "xmlns", prefix, "http://www.w3.org/2000/xmlns/")
                 attrs[attribute] = namespace
 
+        elif len(self.nsmaps) > 1:
+            # There are no new namespaces for this tag, but
+            # non-default namespaces are in play, so we need a
+            # separate tag stack to know when they end.
+            self.nsmaps.append(None)
+
         # Namespaces are in play. Find any attributes that came in
         # from lxml with namespaces attached to their names, and
         # turn then into NamespacedAttribute objects.
@@ -164,16 +169,16 @@
             if namespace is None:
                 new_attrs[attr] = value
             else:
-                nsprefix = self._prefix_for_namespace(namespace)
+                nsprefix = self._prefix_for_attr_namespace(namespace)
                 attr = NamespacedAttribute(nsprefix, attr, namespace)
                 new_attrs[attr] = value
         attrs = new_attrs
 
         namespace, name = self._getNsTag(name)
-        nsprefix = self._prefix_for_namespace(namespace)
+        nsprefix = self._prefix_for_tag_namespace(namespace)
         self.soup.handle_starttag(name, namespace, nsprefix, attrs)
 
-    def _prefix_for_namespace(self, namespace):
+    def _prefix_for_attr_namespace(self, namespace):
         """Find the currently active prefix for the given namespace."""
         if namespace is None:
             return None
@@ -182,16 +187,28 @@
                 return inverted_nsmap[namespace]
         return None
 
+    # To keep the tag prefixes as clean/simple as possible if there is 
+    # more than one possible prefix allowed and it includes None use it instead
+    # This happens when a namespace prefix is added for an attribute that duplicates
+    # an earlier namespace meant for tags that had set that  namespace prefix to None
+    def _prefix_for_tag_namespace(self, namespace):
+        """Find the currently active prefix for the given namespace for a tag."""
+        if namespace is None:
+            return None
+        prefixes = []
+        for inverted_nsmap in self.nsmaps:
+            if inverted_nsmap is not None and namespace in inverted_nsmap:
+                prefixes.append(inverted_nsmap[namespace])
+        if len(prefixes) == 0 or  None in prefixes:
+            return None
+        # ow return the last (most recent) viable prefix
+        return prefixes[-1]
+
     def end(self, name):
         self.soup.endData()
         completed_tag = self.soup.tagStack[-1]
         namespace, name = self._getNsTag(name)
-        nsprefix = None
-        if namespace is not None:
-            for inverted_nsmap in reversed(self.nsmaps):
-                if inverted_nsmap is not None and namespace in inverted_nsmap:
-                    nsprefix = inverted_nsmap[namespace]
-                    break
+        nsprefix = self._prefix_for_tag_namespace(namespace)
         self.soup.handle_endtag(name, nsprefix)
         if len(self.nsmaps) > 1:
             # This tag, or one of its parents, introduced a namespace
diff -ur bs4_4.4_official/dammit.py bs4_4.4_custom/dammit.py
--- bs4_4.4_official/dammit.py	2015-09-05 19:23:38.000000000 -0400
+++ bs4_4.4_custom/dammit.py	2015-09-05 19:56:49.000000000 -0400
@@ -83,6 +83,8 @@
                                            "&(?!#\d+;|#x[0-9a-fA-F]+;|\w+;)"
                                            ")")
 
+    IS_ENTITY = re.compile("(&#\d+;|&#x[0-9a-fA-F]+;|&\w+;)")
+
     AMPERSAND_OR_BRACKET = re.compile("([<>&])")
 
     @classmethod
@@ -116,22 +118,33 @@
 
           Welcome to "Bob's Bar" -> "Welcome to &quot;Bob's bar&quot;
         """
+        """
+          Robustness fix for bs4
+
+          But many other downstream processors of both html and xml 
+          really don't deal well with single quotes instead of the more
+          standard double-quotes.  So simply replace them with their xml 
+          entity regardless
+        """
+
         quote_with = '"'
         if '"' in value:
-            if "'" in value:
-                # The string contains both single and double
-                # quotes.  Turn the double quotes into
-                # entities. We quote the double quotes rather than
-                # the single quotes because the entity name is
-                # "&quot;" whether this is HTML or XML.  If we
-                # quoted the single quotes, we'd have to decide
-                # between &apos; and &squot;.
-                replace_with = "&quot;"
-                value = value.replace('"', replace_with)
-            else:
-                # There are double quotes but no single quotes.
-                # We can use single quotes to quote the attribute.
-                quote_with = "'"
+            # if "'" in value:
+            #     # The string contains both single and double
+            #     # quotes.  Turn the double quotes into
+            #     # entities. We quote the double quotes rather than
+            #     # the single quotes because the entity name is
+            #     # "&quot;" whether this is HTML or XML.  If we
+            #     # quoted the single quotes, we'd have to decide
+            #     # between &apos; and &squot;.
+            #     replace_with = "&quot;"
+            #     value = value.replace('"', replace_with)
+            # else:
+            #     # There are double quotes but no single quotes.
+            #     # We can use single quotes to quote the attribute.
+            #     quote_with = "'"
+            replace_with = "&quot;"
+            value = value.replace('"', replace_with)
         return quote_with + value + quote_with
 
     @classmethod
@@ -189,8 +202,16 @@
         character with "&eacute;" will make it more readable to some
         people.
         """
-        return cls.CHARACTER_TO_HTML_ENTITY_RE.sub(
-            cls._substitute_html_entity, s)
+        # ignore already existing entities
+        pieces = cls.IS_ENTITY.split(s)
+        for i in range(0,len(pieces),2):
+            piece = pieces[i]
+            pieces[i] = cls.CHARACTER_TO_HTML_ENTITY_RE.sub(cls._substitute_html_entity, piece)
+        return "".join(pieces)
+
+        # return cls.CHARACTER_TO_HTML_ENTITY_RE.sub(
+        #     cls._substitute_html_entity, s)
+
 
 
 class EncodingDetector:
diff -ur bs4_4.4_official/element.py bs4_4.4_custom/element.py
--- bs4_4.4_official/element.py	2015-09-05 19:23:39.000000000 -0400
+++ bs4_4.4_custom/element.py	2015-09-05 20:22:33.000000000 -0400
@@ -10,6 +10,15 @@
 
 whitespace_re = re.compile("\s+")
 
+
+NON_BREAKING_INLINE_TAGS = ("a","abbr","acronym","b","bdo","big","cite","code",
+                            "dfn","em","i","img","kbd","small","span","strike",
+                            "strong","sub","sup","tt")
+
+EBOOK_XML_PARENT_TAGS = ("package","metadata","manifest","spine","guide","ncx",
+                         "head","doctitle","docauthor","navmap", "navpoint",
+                          "navlabel", "pagelist", "pagetarget") 
+
 def _alias(attr):
     """Alias one attribute name to another for backward compatibility"""
     @property
@@ -115,7 +124,7 @@
     @classmethod
     def substitute_xml(cls, ns):
         return cls._substitute_if_appropriate(
-            ns, EntitySubstitution.substitute_xml)
+            ns, EntitySubstitution.substitute_xml_containing_entities)
 
 class PageElement(object):
     """Contains the navigational information for some part of the page
@@ -846,6 +855,12 @@
     isSelfClosing = is_empty_element  # BS3
 
     @property
+    def is_non_breaking_inline_tag(self):
+        # used only for pretty printing of html to prevent returns after tags
+        # from introducing spaces where none are desired
+        return self.name in NON_BREAKING_INLINE_TAGS and not self._is_xml
+
+    @property
     def string(self):
         """Convenience property to get the single string within this tag.
 
@@ -1045,22 +1060,23 @@
 
     def encode(self, encoding=DEFAULT_OUTPUT_ENCODING,
                indent_level=None, formatter="minimal",
-               errors="xmlcharrefreplace"):
+               errors="xmlcharrefreplace", indent_chars=" "):
         # Turn the data structure into Unicode, then encode the
         # Unicode.
-        u = self.decode(indent_level, encoding, formatter)
+        u = self.decode(indent_level=indent_level, encoding=encoding, formatter=formatter, indent_chars=indent_chars)
         return u.encode(encoding, errors)
 
     def _should_pretty_print(self, indent_level):
         """Should this tag be pretty-printed?"""
         return (
             indent_level is not None and
-            (self.name not in HTMLAwareEntitySubstitution.preformatted_tags
+            ((not self.name in HTMLAwareEntitySubstitution.preformatted_tags 
+              and not self.name in NON_BREAKING_INLINE_TAGS)
              or self._is_xml))
 
     def decode(self, indent_level=None,
                eventual_encoding=DEFAULT_OUTPUT_ENCODING,
-               formatter="minimal"):
+               formatter="minimal", indent_chars=" "):
         """Returns a Unicode representation of this tag and its contents.
 
         :param eventual_encoding: The tag is destined to be
@@ -1103,6 +1119,13 @@
         if self.prefix:
             prefix = self.prefix + ":"
 
+        if self._is_xml and self.can_be_empty_element:
+            # for pure xml, a self closing tag with only whitespace 
+            # "contents" should be treated as empty
+            tagcontents = self.string
+            if tagcontents is not None and len(tagcontents.strip()) == 0:
+                self.contents = []
+
         if self.is_empty_element:
             close = '/'
         else:
@@ -1112,14 +1135,14 @@
         space = ''
         indent_space = ''
         if indent_level is not None:
-            indent_space = (' ' * (indent_level - 1))
+            indent_space = (indent_chars * (indent_level - 1))
         if pretty_print:
             space = indent_space
             indent_contents = indent_level + 1
         else:
             indent_contents = None
         contents = self.decode_contents(
-            indent_contents, eventual_encoding, formatter)
+            indent_contents, eventual_encoding, formatter, indent_chars)
 
         if self.hidden:
             # This is the 'document root' object.
@@ -1143,7 +1166,7 @@
             if pretty_print and closeTag:
                 s.append(space)
             s.append(closeTag)
-            if indent_level is not None and closeTag and self.next_sibling:
+            if indent_level is not None and closeTag and self.next_sibling and not self.is_non_breaking_inline_tag:
                 # Even if this particular tag is not pretty-printed,
                 # we're now done with the tag, and we should add a
                 # newline if appropriate.
@@ -1151,15 +1174,15 @@
             s = ''.join(s)
         return s
 
-    def prettify(self, encoding=None, formatter="minimal"):
+    def prettify(self, encoding=None, formatter="minimal", indent_chars=" "):
         if encoding is None:
-            return self.decode(True, formatter=formatter)
+            return self.decode(True, formatter=formatter, indent_chars=indent_chars)
         else:
-            return self.encode(encoding, True, formatter=formatter)
+            return self.encode(encoding, True, formatter=formatter, indent_chars=indent_chars)
 
     def decode_contents(self, indent_level=None,
                        eventual_encoding=DEFAULT_OUTPUT_ENCODING,
-                       formatter="minimal"):
+                       formatter="minimal", indent_chars=" "):
         """Renders the contents of this tag as a Unicode string.
 
         :param indent_level: Each line of the rendering will be
@@ -1187,21 +1210,208 @@
             if isinstance(c, NavigableString):
                 text = c.output_ready(formatter)
             elif isinstance(c, Tag):
-                s.append(c.decode(indent_level, eventual_encoding,
-                                  formatter))
-            if text and indent_level and not self.name == 'pre':
+                val = c.decode(indent_level, eventual_encoding, formatter, indent_chars)
+                if pretty_print:
+                    # note, BS4 serializes in an ass-backwards manner using recursion on a tag level basis
+                    # and therefore can not see if the previous line ended with a linefeed or not
+                    
+                    # So we need to remove any bad initial indentation from non breaking inline tags
+                    # that do not start a line as the decode routine can not tell where the tag in in relation
+                    # to other tags and previous newlines
+                    if c.is_non_breaking_inline_tag and len(s) > 0:
+                        val = val.lstrip()
+                s.append(val)
+            if text and indent_level and not self.name == 'pre' and not self.is_non_breaking_inline_tag:
                 text = text.strip()
             if text:
-                if pretty_print and not self.name == 'pre':
-                    s.append(" " * (indent_level - 1))
+                if pretty_print and not self.name == 'pre' and not self.is_non_breaking_inline_tag:
+                    if len(s) == 0 or s[-1] == "\n":
+                        s.append(indent_chars * (indent_level - 1))
                 s.append(text)
-                if pretty_print and not self.name == 'pre':
+                if pretty_print and not self.name == 'pre' and not isinstance(c, NavigableString):
                     s.append("\n")
         return ''.join(s)
 
+    def decodexml(self, indent_level=0, eventual_encoding=DEFAULT_OUTPUT_ENCODING, 
+               formatter="minimal", indent_chars=" "):
+
+        # First off, turn a string formatter into a function. This
+        # will stop the lookup from happening over and over again.
+        if not isinstance(formatter, collections.Callable):
+            formatter = self._formatter_for_name(formatter)
+
+        is_xmlparent = self.name.lower() in EBOOK_XML_PARENT_TAGS
+        attrs = []
+        if self.attrs:
+            for key, val in sorted(self.attrs.items()):
+                if val is None:
+                    decoded = key
+                else:
+                    if isinstance(val, list) or isinstance(val, tuple):
+                        val = ' '.join(val)
+                    elif not isinstance(val, str):
+                        val = str(val)
+                    elif (
+                        isinstance(val, AttributeValueWithCharsetSubstitution)
+                        and eventual_encoding is not None):
+                        val = val.encode(eventual_encoding)
+
+                    text = self.format_string(val, formatter)
+                    decoded = (
+                        str(key) + '='
+                        + EntitySubstitution.quoted_attribute_value(text))
+                attrs.append(decoded)
+
+        prefix = ''
+        if self.prefix:
+            prefix = self.prefix + ":"
+
+        # for pure xml, a self closing tag with only whitespace 
+        # "contents" should be treated as empty
+        if self.can_be_empty_element:
+            tagcontents = self.string
+            if tagcontents is not None and len(tagcontents.strip()) == 0:
+                self.contents = []
+        
+        close = ''
+        closeTag = ''
+        if self.is_empty_element:
+            close = '/'
+        else:
+            closeTag = '</%s%s>' % (prefix, self.name)
+
+        indent_space = (indent_chars * (indent_level - 1))
+        indent_contents = indent_level
+        if is_xmlparent or self.hidden:
+            indent_contents = indent_level + 1
+
+        contents = self.decodexml_contents(indent_contents, eventual_encoding, formatter, indent_chars)
+        if self.hidden:
+            # This is the 'document root' object.
+            s = contents
+        else:
+            s = []
+            attribute_string = ''
+            if attrs:
+                attribute_string = ' ' + ' '.join(attrs)
+            s.append(indent_space)
+            s.append('<%s%s%s%s>' % (prefix, self.name, attribute_string, close))
+            if is_xmlparent:
+                s.append("\n")
+            s.append(contents)
+            if contents and contents[-1] != "\n" and is_xmlparent or self.is_empty_element:
+                s.append("\n")
+            if closeTag and is_xmlparent:
+                s.append(indent_space)
+            s.append(closeTag)
+            if closeTag and self.next_sibling:
+                s.append("\n")
+            s = ''.join(s)
+        return s
+
+    def decodexml_contents(self, indent_level=0, eventual_encoding=DEFAULT_OUTPUT_ENCODING, 
+                        formatter="minimal", indent_chars=" "):
+        """Renders the contents of this tag as a Unicode string.
+        """
+        # First off, turn a string formatter into a function. This
+        # will stop the lookup from happening over and over again.
+        if not isinstance(formatter, collections.Callable):
+            formatter = self._formatter_for_name(formatter)
+
+        is_xmlparent = self.name.lower() in EBOOK_XML_PARENT_TAGS
+        s = []
+        for c in self:
+            text = None
+            if isinstance(c, NavigableString):
+                text = c.output_ready(formatter)
+            elif isinstance(c, Tag):
+                val = c.decodexml(indent_level, eventual_encoding, formatter, indent_chars)
+                s.append(val)
+            if text:
+                text = text.strip()
+            if text:
+                if is_xmlparent and len(s) == 0:
+                    s.append(indent_chars * (indent_level - 1))
+                s.append(text)
+        return ''.join(s)
+
+    def serialize(self, eventual_encoding=DEFAULT_OUTPUT_ENCODING):
+        formatter = self._formatter_for_name('minimal')
+        prefix = ''
+        close = ''
+        closeTag = ''
+        attrs = []
+        if self.attrs:
+            for key, val in sorted(self.attrs.items()):
+                if val is None:
+                    ntext = key
+                else:
+                    if isinstance(val, list) or isinstance(val, tuple):
+                        val = ' '.join(val)
+                    elif not isinstance(val, str):
+                        val = str(val)
+                    elif (isinstance(val, AttributeValueWithCharsetSubstitution) and 
+                          eventual_encoding is not None):
+                        val = val.encode(eventual_encoding)
+                    text = self.format_string(val, formatter)
+                    ntext = (str(key) + '=' + EntitySubstitution.quoted_attribute_value(text))
+                attrs.append(ntext)
+
+        if self.prefix:
+            prefix = self.prefix + ":"
+
+        if self._is_xml and self.can_be_empty_element:
+            # for pure xml, a self closing tag with only whitespace 
+            # "contents" should be treated as empty
+            tagcontents = self.string
+            if tagcontents is not None and len(tagcontents.strip()) == 0:
+                self.contents = []
+
+        if self.is_empty_element:
+            close = '/'
+        else:
+            closeTag = '</%s%s>' % (prefix, self.name)
+
+        contents = self.serialize_contents(eventual_encoding)
+
+        # strip extraneous whitespace before the primary closing tag
+        if self.name in ['html', 'body']:
+            contents = contents.strip()
+            contents += "\n"
+
+        if self.hidden:
+            # This is the 'document root' object.
+            s = contents
+        else:
+            s = []
+            attribute_string = ''
+            if attrs:
+                attribute_string = ' ' + ' '.join(attrs)
+            s.append('<%s%s%s%s>' % (prefix, self.name, attribute_string, close))
+            if self.name in ['html', 'body']:
+                s.append("\n")
+            s.append(contents)
+            s.append(closeTag)
+            if self.name in ['html', 'body']:
+                s.append("\n")
+            s = ''.join(s)
+        return s
+
+    def serialize_contents(self, eventual_encoding=DEFAULT_OUTPUT_ENCODING):
+        formatter = self._formatter_for_name('minimal')
+        s = []
+        for c in self:
+            text = None
+            if isinstance(c, NavigableString):
+                text = c.output_ready(formatter)
+                s.append(text)
+            elif isinstance(c, Tag):
+                s.append(c.serialize(eventual_encoding))
+        return ''.join(s)
+
     def encode_contents(
         self, indent_level=None, encoding=DEFAULT_OUTPUT_ENCODING,
-        formatter="minimal"):
+        formatter="minimal", indent_chars=" "):
         """Renders the contents of this tag as a bytestring.
 
         :param indent_level: Each line of the rendering will be
@@ -1213,7 +1423,7 @@
            entities to Unicode characters.
         """
 
-        contents = self.decode_contents(indent_level, encoding, formatter)
+        contents = self.decode_contents(indent_level, encoding, formatter, indent_chars)
         return contents.encode(encoding)
 
     # Old method for BS3 compatibility
